- 클래스에는 객체가 가져야 할 구성 멤버가 선언된다.
- 필드(Field), 생성자(Constructor), 메소드(Method)
- 위 구성 요소는 생략될 수 있고 복수개일수 있다.
- 필드 : 객체의 데이터가 저장되는 곳	# int fieldName;
- 생성자 : 객체 생성 시 초기화 역할 담당	# ClassName(){}
- 메소드 : 객체의 동작에 해당하는 실행 블록

1. 필드
- 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
- 변수와 구분되는데 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다.
- 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.
- 필드 선언은 클래스 중괄호 블록 어디서든 존재할 수 있다.
- 생성자와 메소드 중괄호 블록 내부에는 선언할 수 없다.
- 필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다.
- 클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만, 클래스외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다.


2. 생성자
- 역할 : 객체 생성 시 초기화를 담당
- 생성자는 클래스 이름으로 되어 있고 리턴 타입이 없다.
- 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
- new 연산자에 의해 생성자가성공적으로 실행되면 힙 영역에 객체가 생성되고 객체의 주소가 리턴된다.
2-1. 기본 생성자
- 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다.
- 사용자가 클래스 내부에 생성자를 생략했다면 컴파일러는 비어있는 기본 생성자를 바이트 코드에 자동 추가시킨다.
- 클래스에 명시적으로 선언한 생성자가 한개라도 있다면 컴파일러는 기본 생성자를 추가하지 않는다.
2-2. 생성자 선언
클래스(매개변수, ...){
	// 객체 초기화 코드
}
- 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다.
2-3. 필드 초기화
- 필드 초기화 하는 방법
	- 필드를 선언할 때 초기화 : 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게 된다.
	- 생성자에서 초기화 : 외부에서 제공되는 다양한 값들로 초기화 하고 싶을 때 사용
		- 매개 변수 값을 필드 이름과 동일하게 하는 것이 관례적이다.
		- 이 때, 생성자 내부에서 필드에 접근할 수 없으므로 this.필드 = 매개변수; 처럼 this를 붙인다.
2-4. 생성자 오버로딩
- 매개변수를 달리하는 생성자를 여러개 선언하는 것을 말한다.
- 매개변수의 타입, 개수, 순서를 다르게 선언해야 한다.
- 생성자가 오버로딩 되었을 경우, new 연산자를 사용해서 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자를 결정한다.
2-5. 다른 생서자 호출(this())
- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다.
- 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
- 생성자에서 다른 생성자를 호출할 때
클래스(매개변수선언,..){
	this(매개변수, ..., 값, ...);	// 클래스의 다른 생성자호출
	실행문;
}
- this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.

3. 메소드
- 객체의 동작에 해당한다.
- 매개 변수는 생략하거나 여러개 넣을 수 있으며, new연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.
- 클래스에 생성자가 명시적으로 선언되어 있을 경우에는 반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다.
