- 클래스에는 객체가 가져야 할 구성 멤버가 선언된다.
- 필드(Field), 생성자(Constructor), 메소드(Method)
- 위 구성 요소는 생략될 수 있고 복수개일수 있다.
- 필드 : 객체의 데이터가 저장되는 곳	# int fieldName;
- 생성자 : 객체 생성 시 초기화 역할 담당	# ClassName(){}
- 메소드 : 객체의 동작에 해당하는 실행 블록

1. 필드
- 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
- 변수와 구분되는데 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다.
- 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.
- 필드 선언은 클래스 중괄호 블록 어디서든 존재할 수 있다.
- 생성자와 메소드 중괄호 블록 내부에는 선언할 수 없다.
- 필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다.
- 클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만, 클래스외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다.


2. 생성자
- 역할 : 객체 생성 시 초기화를 담당
- 생성자는 클래스 이름으로 되어 있고 리턴 타입이 없다.
- 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
- new 연산자에 의해 생성자가성공적으로 실행되면 힙 영역에 객체가 생성되고 객체의 주소가 리턴된다.
2-1. 기본 생성자
- 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다.
- 사용자가 클래스 내부에 생성자를 생략했다면 컴파일러는 비어있는 기본 생성자를 바이트 코드에 자동 추가시킨다.
- 클래스에 명시적으로 선언한 생성자가 한개라도 있다면 컴파일러는 기본 생성자를 추가하지 않는다.
2-2. 생성자 선언
클래스(매개변수, ...){
	// 객체 초기화 코드
}
- 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다.
2-3. 필드 초기화
- 필드 초기화 하는 방법
	- 필드를 선언할 때 초기화 : 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게 된다.
	- 생성자에서 초기화 : 외부에서 제공되는 다양한 값들로 초기화 하고 싶을 때 사용
		- 매개 변수 값을 필드 이름과 동일하게 하는 것이 관례적이다.
		- 이 때, 생성자 내부에서 필드에 접근할 수 없으므로 this.필드 = 매개변수; 처럼 this를 붙인다.
2-4. 생성자 오버로딩
- 매개변수를 달리하는 생성자를 여러개 선언하는 것을 말한다.
- 매개변수의 타입, 개수, 순서를 다르게 선언해야 한다.
- 생성자가 오버로딩 되었을 경우, new 연산자를 사용해서 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자를 결정한다.
2-5. 다른 생서자 호출(this())
- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다.
- 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
- 생성자에서 다른 생성자를 호출할 때
클래스(매개변수선언,..){
	this(매개변수, ..., 값, ...);	// 클래스의 다른 생성자호출
	실행문;
}
- this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.

3. 메소드
- 객체의 동작에 해당한다.
- 매개 변수는 생략하거나 여러개 넣을 수 있으며, new연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.
- 클래스에 생성자가 명시적으로 선언되어 있을 경우에는 반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다.
3-1. 메소드 선언
- 선언부(리턴타입, 메소드이름, 매개변수선언)와 실행 블록으로 구성된다.
- 메소드 선언부를 메소드 시그니처라고도 한다.
접근지정자 리턴타입 메소드이름(매개변수선언,..){
	실행할 코드
}
- 리턴 타입 : 메소드가 실행 후 리턴하는 값의 타입
- 메소드는 리턴값이 있을수도 있고, 없을수도 있다.
- 메소드가 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴값이 있어야 한다.
- 리턴값이 없는 메소드는 리턴 타입에 void가 와야 하며, 리턴값이 잆는 메소드는 리턴값의 타입이 와야 한다.
- 리턴값이 없는 메소드를 호출할 경우 메소드 이름으로 호출하면 된다.
- 리턴값이 있는 메소드를 호출할 경우 리턴 타입에 맞는 변수에서 호출해야 한다. 리턴 타입이 있다고 해서 반드시 리턴값을 변수에 저장할 필요는 없다.
3-2. 메소드 이름
- 숫자로 시작x, 관례적으로 메소드명은 소문자로 작성
- 메소드 이름은 메소드가 어떤 기능을 수행하는지 쉽게 알 수 있도록 기능 이름으로 지어주는 것이 좋다.
3-3. 매개 변수 선언
- 매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다.
3-4. 매개 변수의 수를 모를 경우
- 경우에 따라 메소드를 선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다.
- 이 경우 매개 변수를 배열 타입으로 선언하면 된다.
int sum1(int[] values){}
int[] values = {1,2,3};
int result = sum1(values);
int result = sum1(new int[] {1,2,3,4,5});
- 매개 변수 타입을 배열 타입으로 선언하면, 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.
- 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다.
int sum2(int ... values){} // ... 사용 시 메소드 호출 시 넘겨준 값의수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.
int result = sum2(1,2,3);
int result = sum2(1,2,3,4);
3-5. return 문
- 리턴 값이 있는 메소드
	- 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 한다.
	- return문이 실행되면 메소드는 즉시 종료된다.
	- return문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 한다.
	- return문 이후에 실행문이 오면 "Unreachable code"라는 컴파일 오류가 발생한다.
- 리턴 값이 없는 메소드
	- void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할수 있다.
	- 메소드 실행을 강제 종료시킨다.
3-6. 메소드 호출
- 메소드는 클래스 내,외부의 호출에 의해 실행된다.
- 객체 내부에서 호출
	메소드(매개값, ...);
- 객체 외부에서 호출
	- 외부 클래스에서 메소드를 호출하려면 클래스로부터 객체를 생성해야 한다.
	클래스 참조변수 = new 클래스(매개값, ...);
	참조변수.메소드(매개값,...);
	타입 변수 = 참조변수.메소드(매개값,...);
3-7. 메소드 오버로딩
- 클래스 내에 같은 이름의 메소드를 여러개 선언하는 것을 메소드 오버로딩이라고 한다.
- 메소드 오버로딩의 조건은 매개변수 타입, 개수, 순서 중 하나가 달라야 한다.
Class 클래스{
	리턴타입 메소드이름 (타입, 변수, ..){}
	리턴타입 메소드이름 (타입, 변수, ...){}
}
- 필요한 이유 : 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서이다.
- 오버로딩 된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다.
